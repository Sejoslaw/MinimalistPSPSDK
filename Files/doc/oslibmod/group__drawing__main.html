<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Main</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__drawing__main.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Main</h1>  </div>
<div class="ingroups"><a class="el" href="group__drawing.html">Drawing</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#ga28796a7eaa209195f3e6eebf54692799">oslInitGfx</a> (int pixelFormat, int bDoubleBuffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#gaee41f26ce4d9733a781efa9c0c2b9543">oslStartDrawing</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#ga31e0a6c7bb6f568ff89bb14b1ad33924">oslEndDrawing</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#ga1a66d3cdc0e26ae1a38cc0cc75b23419">oslSyncDrawing</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#ga23c78b842cc2a53ed44e1845400259c9">oslSwapBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#gab70e06bf02e845eebea2982ffc8a70b1">oslEndGfx</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drawing__main.html#ga39abb0fdf82305563299fc79119d79de">oslSetSysDisplayListSize</a> (int newSize)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Main and configuration routines of the drawing part of OSLib. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga28796a7eaa209195f3e6eebf54692799"></a><!-- doxytag: member="drawing.h::oslInitGfx" ref="ga28796a7eaa209195f3e6eebf54692799" args="(int pixelFormat, int bDoubleBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslInitGfx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDoubleBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes the graphical part of OSLib. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>Defines the screen resolution.</p>
<ul>
<li>OSL_PF_8888: 32-bit render, very precise and nice, especially when it comes to gradients. However requires twice the memory required by the 16-bit mode (1088 kilobytes in double buffer mode, half in single buffer mode). Also uses more bandwidth and thus is slower.</li>
<li>OSL_PF_5650: 16-bit render, can only display 65 thousand colors instead of 16 millions. Requires 544 kB in double buffer mode, and half in single buffer mode. It's the recommended mode. Use oslSetDithering to simulate more colors with dithering. </li>
</ul>
</td></tr>
    <tr><td class="paramname">bDoubleBuffer</td><td>A game will always use double buffering (else flickering will appear), let it to TRUE (1) except if you really know what you are doing. Look at oslSwapBuffers for more information.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: you can call it as many times as you want. However, any images placed in video memory (OSL_IN_VRAM) will be invalidated after a call to oslInitGfx, so make sure to delete all of them before, else you'll encounter (very) weird and random problems! </p>

</div>
</div>
<a class="anchor" id="gaee41f26ce4d9733a781efa9c0c2b9543"></a><!-- doxytag: member="drawing.h::oslStartDrawing" ref="gaee41f26ce4d9733a781efa9c0c2b9543" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslStartDrawing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts drawing with OSLib. Call this before trying to draw anything. </p>

</div>
</div>
<a class="anchor" id="ga31e0a6c7bb6f568ff89bb14b1ad33924"></a><!-- doxytag: member="drawing.h::oslEndDrawing" ref="ga31e0a6c7bb6f568ff89bb14b1ad33924" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslEndDrawing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ends drawing. Call this once you've finished your render. This command will wait for the GPU to finish its render, and thus can be slow. Though, OSLib can use this remaining time to render and output sound. </p>

</div>
</div>
<a class="anchor" id="ga1a66d3cdc0e26ae1a38cc0cc75b23419"></a><!-- doxytag: member="drawing.h::oslSyncDrawing" ref="ga1a66d3cdc0e26ae1a38cc0cc75b23419" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslSyncDrawing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oslSyncDrawing waits for the GPU (that's how I'm calling the graphic processor; some say GE, meaning Graphic Engine) rendering to finish. As rendering is done in parallel with the CPU, you may be modifying an image which is currently used by the GPU, and thus render will be incorrect. In this case you should first issue a oslSyncDrawing to be sure the GPU is not active anymore and modify what you want after that. Howerver, take note that synchronizing with the GPU waits that it ends everythings it's doing, and thus can be VERY slow, so avoid doing it except if you really need it and if you know what you are doing.</p>
<p>Note: The amount of things you can draw between a call to oslStartDrawing and oslEndDrawing is limited because commands are sent to the GPU, and they are stored in the so called display list, which has a limited size. If you overflow the display list size, your program will crash (or have very weird behaviour). oslSyncDrawing waits the GPU to finish to execute the display list and resets it to zero (as oslStartDrawing / oslEndDrawing do: oslSyncDrawing is just a faster way to call both one after the other, it just skips end and beginning of frame processes). So, if you are really drawing a lot of things at once and your program is crashing, try to put a oslSyncDrawing somewhere. </p>

</div>
</div>
<a class="anchor" id="ga23c78b842cc2a53ed44e1845400259c9"></a><!-- doxytag: member="drawing.h::oslSwapBuffers" ref="ga23c78b842cc2a53ed44e1845400259c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslSwapBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swaps buffers. In double buffering mode, call it once per frame. The utility of double buffering is to avoid flickering, because if you only have one buffer, the buffer displayed on the screen is the same which you are drawing to. And thus the screen will show everything you're making with the buffer! So let's say you first draw a sky and then a sprite over it, the user will first see the sky and the sprite flickering.</p>
<p>With double buffering though you have one buffer which is displayed, and another (hidden) you're drawing to. Once rendering to the hidden buffer is terminated, you can show it to the user: this is swapping buffers. The user will now see the hidden buffer (which is complete now) and the other buffer will now become hidden so that you can draw another frame to it, and so on. </p>

</div>
</div>
<a class="anchor" id="gab70e06bf02e845eebea2982ffc8a70b1"></a><!-- doxytag: member="drawing.h::oslEndGfx" ref="gab70e06bf02e845eebea2982ffc8a70b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslEndGfx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ends the graphical part, releasing memory for the display list. All images placed in video memory (OSL_IN_VRAM) become invalid after calling this, so make sure to release ALL of them before! You will need to reload them after having called oslInitGfx again. </p>

</div>
</div>
<a class="anchor" id="ga39abb0fdf82305563299fc79119d79de"></a><!-- doxytag: member="drawing.h::oslSetSysDisplayListSize" ref="ga39abb0fdf82305563299fc79119d79de" args="(int newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslSetSysDisplayListSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Very advanced command which sets the display list size. Don't use it unless you know what you are doing. Default is 1 MB (megabyte). Don't forget to call oslStartDrawing after a call to this function before beginning to draw again. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue May 17 2011 10:54:47 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
