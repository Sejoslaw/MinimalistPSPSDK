<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pixel access</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__image__pixel.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Pixel access</h1>  </div>
<div class="ingroups"><a class="el" href="group__image.html">Images</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga2abc6cfb0fa391142551f86488599289">oslGetImageLine</a>(img, y)&#160;&#160;&#160;((char*)((img)-&gt;data) + (y)*(((img)-&gt;realSizeX * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaadd9c6315b59af4be74346c54b73f0c1">oslGetImagePixelAddr</a>(img, x, y)&#160;&#160;&#160;((char*)((img)-&gt;data) + ((((y)*(img)-&gt;realSizeX + (x)) * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaecbb87d882a545576b448252ae50cd9e">oslUncacheImageData</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga789fb4f5321897634fddb3aa14e7d6e9">oslUncacheImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gaa20f8d50de53edf75802faf747b2aa66">oslSetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y, int pixelValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga85cb0dd8941f90352335474d51fc69f9">oslGetSwizzledPixelAddr</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gac444b3ad613929f5bce6da775f574197">oslConvertColor</a> (int pfDst, int pfSrc, int color)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga767b891aec656ada10b5c8163a9d0e96">oslConvertColorEx</a> (<a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *p, int pfDst, int pfSrc, int color)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__pixel.html#ga99e1b4c623f2ee9591b1b5ee098decb9">osl_paletteSizes</a> []</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Low level access to images. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2abc6cfb0fa391142551f86488599289"></a><!-- doxytag: member="drawing.h::oslGetImageLine" ref="ga2abc6cfb0fa391142551f86488599289" args="(img, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImageLine</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">img, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char*)((img)-&gt;data) + (y)*(((img)-&gt;realSizeX * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the address of the beginning (left border) of an image line. This address can be used to access image raw data. Please note that when doing this, you'll have to respect the pixelformat of the image! If the image is 16 bits (4444, 5551 or 5650) then use a u16 pointer and appropriate RGBxx macros.</p>
<p>Here is an example which fills one line: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Create a 15-bit image (16-bit pixel width as 1 alpha bit is added).</span>
<a class="code" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img = <a class="code" href="group__image__creation.html#ga120ad0461bc8369f9431bff653d25217">oslCreateImage</a>(32, 32, <a class="code" href="group__image.html#gga163a37d9c3999633b0dc387e15453845a40b7f6fda376d3390a38f2d2629a39f7" title="In RAM.">OSL_IN_RAM</a>, <a class="code" href="group__image.html#ggab3528cc93235f479e65017b9cc0a2259a5a0a8c1193ea60a42d6c6dcd6fb62f18" title="15 bits, 5 bits per component, 1 alpha bit">OSL_PF_5551</a>);
<span class="comment">//Get a pointer to the 4th line (0 is the first, 1 the second, ...)</span>
u16 *data = (u16*)<a class="code" href="group__image__pixel.html#ga2abc6cfb0fa391142551f86488599289">oslGetImageLine</a>(img, 3);
<span class="comment">//Loop index variable</span>
<span class="keywordtype">int</span> i;
<span class="comment">//From the beginning to the end of the line...</span>
<span class="keywordflow">for</span> (i=0;i&lt;img-&gt;sizeX;i++)              {
        <span class="comment">//Set this pixel to bright red</span>
        *data = <a class="code" href="group__drawing__color.html#gaac51b4482ade52ca41195dc5840b02ae">RGBA15</a>(255, 0, 0, 255);
        <span class="comment">//Point to the next pixel</span>
        data++;
}
</pre></div> 
</div>
</div>
<a class="anchor" id="gaadd9c6315b59af4be74346c54b73f0c1"></a><!-- doxytag: member="drawing.h::oslGetImagePixelAddr" ref="gaadd9c6315b59af4be74346c54b73f0c1" args="(img, x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImagePixelAddr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">img, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char*)((img)-&gt;data) + ((((y)*(img)-&gt;realSizeX + (x)) * <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat])&gt;&gt;3))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the address of a single pixel of an image. Please note that this works only for 8 to 32 bits pixel types, but not for 4 bits, as the byte is the smallest unit you can work with, and in this case a byte contains 2 pixels. In case of 4 bits, a pointer to the corresponding pixel pair (byte) will be returned, and you'll have to use masks to handle this correctly.</p>
<p>Here is an (untested) example: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> setPixel(<a class="code" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> value)          {
        u8 *data = oslGetImagePixelAdr(x, y);

        <span class="comment">//The pixel value can&#39;t be larger than 4 bits, else we would overflow on the next pixel, messing up the display.</span>
        value &amp;= 0xf;

        <span class="comment">//First method: is x even?</span>
        <span class="keywordflow">if</span> (x &amp; 1)              {
                <span class="comment">//Mask out the last 4 bits</span>
                data &amp;= 0x0f;
                <span class="comment">//Write to the last 4 bits</span>
                data |= value &lt;&lt; 4;
        }
        <span class="keywordflow">else</span>    {
                <span class="comment">//Mask out the first 4 bits</span>
                data &amp;= 0xf0;
                <span class="comment">//Write to the first 4 bits</span>
                data |= value;
        }

        <span class="comment">//Second method: directly integrate the parity checking</span>
        data &amp;= ~(15 &lt;&lt; ((x &amp; 1) &lt;&lt; 2));
        data |= value &lt;&lt; ((x &amp; 1) &lt;&lt; 2);
}
</pre></div> 
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaecbb87d882a545576b448252ae50cd9e"></a><!-- doxytag: member="drawing.h::oslUncacheImageData" ref="gaecbb87d882a545576b448252ae50cd9e" args="(OSL_IMAGE *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslUncacheImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flushes the image data from the cache. Never forget to call this after you've modified an image in a cached way (by default all the following routines do). See oslUncacheData for more information.</p>
<p>Note: this routine does not flush the associated image palette data! Call oslUncacheImage instead if you need it! </p>

</div>
</div>
<a class="anchor" id="ga789fb4f5321897634fddb3aa14e7d6e9"></a><!-- doxytag: member="drawing.h::oslUncacheImage" ref="ga789fb4f5321897634fddb3aa14e7d6e9" args="(OSL_IMAGE *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslUncacheImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Uncache a whole image, including its associated palette (image-&gt;palette). </p>

</div>
</div>
<a class="anchor" id="gaa17750f92f8395b04b76cd58d3332c5d"></a><!-- doxytag: member="drawing.h::oslGetImagePixel" ref="gaa17750f92f8395b04b76cd58d3332c5d" args="(OSL_IMAGE *img, unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslGetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>High-level routine which reads a single pixel on an image. Beware, caching is enabled, so after finished reading and/or writing pixels to an image, please take care to uncache your image! The best and cleaner way to do it is to use <a class="el" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a> and <a class="el" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>. See <a class="el" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a> for an example.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the pixel at that position. The value depends on the pixelformat, it can be a palette entry number if the image is paletted, or a color in the format of the image (so you may have to convert it depending on what you'd like).</dd></dl>
<div class="fragment"><pre class="fragment"><span class="comment">//Get a 32 bit (OSL_PF_8888) color for the pixel at x, y, whatever its pixelformat is.</span>
pixel = <a class="code" href="group__image__pixel.html#ga767b891aec656ada10b5c8163a9d0e96">oslConvertColorEx</a>(yourImage-&gt;palette, <a class="code" href="group__image.html#ggab3528cc93235f479e65017b9cc0a2259a1aeaeefa432a52c184d8795655b4c525" title="32 bits, 8 bits per component, 8 alpha bits">OSL_PF_8888</a>, yourImage-&gt;pixelFormat, <a class="code" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a>(yourImage, x, y));
</pre></div><p>Note: This routine also works for swizzled images!</p>
<p><b>Note:</b> this routine is rather slow, you should consider raw access if you need good performance. </p>

</div>
</div>
<a class="anchor" id="gaa20f8d50de53edf75802faf747b2aa66"></a><!-- doxytag: member="drawing.h::oslSetImagePixel" ref="gaa20f8d50de53edf75802faf747b2aa66" args="(OSL_IMAGE *img, unsigned int x, unsigned int y, int pixelValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslSetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pixelValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a pixel on the image. Same remarks as for oslGetImagePixel apply. The value is in the destination format of the image (so, either a palette entry or a color in the good format). Use conversions if needed, as shown in the example above. Here is another example that does calculation on every pixel of an image.</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Before doing low level operations on an image, we first need to lock it, it takes care of low level cache operations.</span>
<a class="code" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a>(image);
{
        <span class="comment">//The {...} block is just for estethic, not necessary</span>
        <span class="keywordflow">for</span> (j=0;j&lt;image-&gt;sizeY;j++)            {
                <span class="keywordflow">for</span> (i=0;i&lt;image-&gt;sizeX;i++)            {
                        <span class="comment">//Get a pixel of the image (depends on its pixelformat, here we assume it&#39;s 8888)</span>
                        u32 pixel = <a class="code" href="group__image__pixel.html#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a>(image, i, j);
                        <span class="comment">//Mask out the green and blue components</span>
                        <a class="code" href="group__image__pixel.html#gaa20f8d50de53edf75802faf747b2aa66">oslSetImagePixel</a>(image, i, j, pixel &amp; 0xff0000ff);
                }
        }
}
<a class="code" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>(image);
</pre></div> 
</div>
</div>
<a class="anchor" id="ga85cb0dd8941f90352335474d51fc69f9"></a><!-- doxytag: member="drawing.h::oslGetSwizzledPixelAddr" ref="ga85cb0dd8941f90352335474d51fc69f9" args="(OSL_IMAGE *img, unsigned int x, unsigned int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* oslGetSwizzledPixelAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the address of a pixel, working even if the image is swizzled. This implementation is slower but works in every case. </p>

</div>
</div>
<a class="anchor" id="gac444b3ad613929f5bce6da775f574197"></a><!-- doxytag: member="drawing.h::oslConvertColor" ref="gac444b3ad613929f5bce6da775f574197" args="(int pfDst, int pfSrc, int color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a color. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pfDst</td><td>Destination pixel format. </td></tr>
    <tr><td class="paramname">pfSrc</td><td>Source pixel format. </td></tr>
    <tr><td class="paramname">color</td><td>Color (in the source pixel format). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga767b891aec656ada10b5c8163a9d0e96"></a><!-- doxytag: member="drawing.h::oslConvertColorEx" ref="ga767b891aec656ada10b5c8163a9d0e96" args="(OSL_PALETTE *p, int pfDst, int pfSrc, int color)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColorEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pfSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a color but using a palette if either the source or destination pixel format are paletted. See oslGetImagePixel for an example of use. </p>

</div>
</div>
<a class="anchor" id="ga1e009683f250dbeeeb7d8cb304b58ddd"></a><!-- doxytag: member="drawing.h::oslLockImage" ref="ga1e009683f250dbeeeb7d8cb304b58ddd" args="(OSL_IMAGE *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslLockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Locks an image, so that you can access it. Althrough not necessary, this is a good thing to do because it will automatically handle drawing to the drawbuffer, uncaching the image when finished and flushing the texture cache to avoid render errors when an image is modified while it's being drawn. </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Lock the image</span>
<a class="code" href="group__image__pixel.html#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a>(myImage);
{
        <span class="comment">//Do some software access to the image</span>
        u16 *ptr = (u16*)myImage-&gt;data;
        *ptr = 0;
}
<span class="comment">//Unlock it after having finished</span>
<a class="code" href="group__image__pixel.html#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>(myImage);

<span class="comment">//We can now draw it!</span>
<a class="code" href="group__image__drawing.html#gaf6b7b3f250d1fd2d961d55686528a276">oslDrawImage</a>(myImage);
</pre></div> 
</div>
</div>
<a class="anchor" id="ga483de8582f4bdf0ec946e16f0cbd8856"></a><!-- doxytag: member="drawing.h::oslUnlockImage" ref="ga483de8582f4bdf0ec946e16f0cbd8856" args="(OSL_IMAGE *img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslUnlockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlock the image after you've finished with it. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gae84026314c01744128932407470bc75b"></a><!-- doxytag: member="drawing.h::osl_pixelWidth" ref="gae84026314c01744128932407470bc75b" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="group__image__pixel.html#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of pixel widths (in bits) for each pixel format. </p>

</div>
</div>
<a class="anchor" id="ga99e1b4c623f2ee9591b1b5ee098decb9"></a><!-- doxytag: member="drawing.h::osl_paletteSizes" ref="ga99e1b4c623f2ee9591b1b5ee098decb9" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const u8 <a class="el" href="group__image__pixel.html#ga99e1b4c623f2ee9591b1b5ee098decb9">osl_paletteSizes</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of palette sizes (in powers of two). For non-paletted formats, it is zero. Else you can get the palette size by doing 1 &lt;&lt; osl_paletteSizes[pixelFormat]. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue May 17 2011 10:54:47 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
