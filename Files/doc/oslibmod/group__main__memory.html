<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__main__memory.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Memory</h1>  </div>
<div class="ingroups"><a class="el" href="group__main.html">Main</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gaac62fc853a69d2f3a2d07c4afcfb33aa">oslUncacheData</a>(data, size)&#160;&#160;&#160;sceKernelDcacheWritebackInvalidateRange(data, size);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga49c3ace53936b45bcb86d36935ac01c5">oslGetUncachedPtr</a>(adr)&#160;&#160;&#160;((void*)((int)(adr)|0x40000000))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga204d2c76e11ccd5f70a0b7f925566aa3">oslGetCachedPtr</a>(adr)&#160;&#160;&#160;((void*)((int)(adr)&amp;(~0x40000000)))</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga2272bf44bae6ed8f27e3a60b7226dcbe">sceDmacMemcpy</a> (void *dest, const void *source, unsigned int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga1557c9b83879112e2a4c3a1af791652a">sceDmacTryMemcpy</a> (void *dest, const void *source, unsigned int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gad161d625f2ace18ca2e9847c87b264d1">oslFasterMemset</a> (u64 *dst, u64 *src, u32 length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga61dd77badbdd48d26032b524afc3bd18">oslFlushDataCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#ga7830c609e96fd30a2bed80bb27784e29">memalign</a> (size_t, size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains routines about memory (cache, copy, etc.). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaac62fc853a69d2f3a2d07c4afcfb33aa"></a><!-- doxytag: member="oslib.h::oslUncacheData" ref="gaac62fc853a69d2f3a2d07c4afcfb33aa" args="(data, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslUncacheData</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;sceKernelDcacheWritebackInvalidateRange(data, size);</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine will make sure that the data will no more reside in the CPU cache. The CPU does automatically put data in cache when you want to read or write to it, making subsequent accesses faster (because the cache is way faster than conventional RAM). The problem is that if the GE (graphic processor) for example wants to access it, it will read the real memory, and thus if some data is still sitting in the cache (not written to actual RAM yet) the GE will get incorrect data, making it crash or display corrupt graphics.</p>
<p>To avoid problems, you can either bypass the cache by writting to uncached addresses (oslGetUncachedPtr) or by flushing the data from cache before sending them to the GE (or DMA). This function, oslUncacheData, will flush the actual data from cache, writing it to real memory. This does take some time so don't abuse and call it only when necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Adress of the memory area to flush. </td></tr>
    <tr><td class="paramname">size</td><td>Size (in bytes) of the area.</td></tr>
  </table>
  </dd>
</dl>
<p>Uncaching should be done after you've accessed raw image / palette / something contents. This includes oslSetImagePixel and accesses to the raw image data pointed to by <a class="el" href="struct_o_s_l___i_m_a_g_e.html#a97a8aa1856d84160efd66e51fdf3f797" title="Raw image data in memory.">OSL_IMAGE::data</a>.</p>
<p>Note: There are specific functions to uncache palettes and images, simplier to use. You should rather use them instead. </p>

</div>
</div>
<a class="anchor" id="ga49c3ace53936b45bcb86d36935ac01c5"></a><!-- doxytag: member="oslib.h::oslGetUncachedPtr" ref="ga49c3ace53936b45bcb86d36935ac01c5" args="(adr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetUncachedPtr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr</td><td>)</td>
          <td>&#160;&#160;&#160;((void*)((int)(adr)|0x40000000))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to an uncached address. In this case, cache will be bypassed and you'll not have to call oslUncache[something] after modifying data. However performance is usually worse and caching is a good thing, so do it if you know what you are doing.</p>
<p>Important: NEVER mix cached and uncached addresses when accessing somewhere. Either always access them as cached or unached. If you mix them some weird bugs may appear because you could for example write directly in memory bypassing the cache, but some data is still sitting in the cache. So, once the cache is full, data will be flushed and written to the memory, replacing the data you wrote in an uncached way. You will not understand why your data gets corrupted, and as this will maybe happen seconds later in special circumstances, so it will be impossible to detect or debug. </p>

</div>
</div>
<a class="anchor" id="ga204d2c76e11ccd5f70a0b7f925566aa3"></a><!-- doxytag: member="oslib.h::oslGetCachedPtr" ref="ga204d2c76e11ccd5f70a0b7f925566aa3" args="(adr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetCachedPtr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr</td><td>)</td>
          <td>&#160;&#160;&#160;((void*)((int)(adr)&amp;(~0x40000000)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a pointer to cached data. Same remark as above. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2272bf44bae6ed8f27e3a60b7226dcbe"></a><!-- doxytag: member="oslib.h::sceDmacMemcpy" ref="ga2272bf44bae6ed8f27e3a60b7226dcbe" args="(void *dest, const void *source, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sceDmacMemcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies data using the internal DMAC. Should be faster than a memcpy, but requires that data to be copied is no more in the cache, so usually you should issue a oslUncacheData on the source and destination addresses else very strange bugs may happen. </p>

</div>
</div>
<a class="anchor" id="ga1557c9b83879112e2a4c3a1af791652a"></a><!-- doxytag: member="oslib.h::sceDmacTryMemcpy" ref="ga1557c9b83879112e2a4c3a1af791652a" args="(void *dest, const void *source, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sceDmacTryMemcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as sceDmacMemcpy. </p>

</div>
</div>
<a class="anchor" id="gad161d625f2ace18ca2e9847c87b264d1"></a><!-- doxytag: member="oslib.h::oslFasterMemset" ref="gad161d625f2ace18ca2e9847c87b264d1" args="(u64 *dst, u64 *src, u32 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslFasterMemset </td>
          <td>(</td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64 *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does a memset using the 64-bit capabilities of the CPU. Faster than memcpy. </p>

</div>
</div>
<a class="anchor" id="ga61dd77badbdd48d26032b524afc3bd18"></a><!-- doxytag: member="oslib.h::oslFlushDataCache" ref="ga61dd77badbdd48d26032b524afc3bd18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oslFlushDataCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flushes the whole cache. This is slow, absolutely avoid it! Use oslUncacheData instead if possible. </p>

</div>
</div>
<a class="anchor" id="ga7830c609e96fd30a2bed80bb27784e29"></a><!-- doxytag: member="oslib.h::memalign" ref="ga7830c609e96fd30a2bed80bb27784e29" args="(size_t, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memalign </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a memory block, ensuring it is aligned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">1</td><td>Alignment in bytes </td></tr>
    <tr><td class="paramname">2</td><td>Size of the block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8f51609a9d0f7a1b34d73912e83b01d"></a><!-- doxytag: member="oslib.h::oslGetRamStatus" ref="gac8f51609a9d0f7a1b34d73912e83b01d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> oslGetRamStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets info about currently available memory in main RAM. The return value is a <a class="el" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> structure which contains info about available memory.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">//You can either store the result to a structure and access its members</span>
        <a class="code" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html">OSL_MEMSTATUS</a> ram = <a class="code" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a>();
        <a class="code" href="group__msgbox.html#ga38ea43b36a7f4b5c03b492dd7edaa843">oslDebug</a>(<span class="stringliteral">&quot;%i bytes available&quot;</span>, ram.<a class="code" href="struct_o_s_l___m_e_m_s_t_a_t_u_s.html#a13505b3121233ca59bdeed48398d3048" title="Maximum available memory.">maxAvailable</a>);

        <span class="comment">//Or directly use the return value from the function, like this</span>
        <a class="code" href="group__msgbox.html#ga38ea43b36a7f4b5c03b492dd7edaa843">oslDebug</a>(<span class="stringliteral">&quot;%i bytes available&quot;</span>, <a class="code" href="group__main__memory.html#gac8f51609a9d0f7a1b34d73912e83b01d">oslGetRamStatus</a>().maxAvailable);
</pre></div><p><b>Note:</b> About the example above, just notice that each call to oslGetRamStatus costs a lot of time, so if you need to retrieve several results (e.g. both maxAvailable and maxBlockSize) you should not use the second method as it will need two calls to oslGetRamStatus. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Tue May 17 2011 10:54:47 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
